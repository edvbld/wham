\documentclass[11pt,oneside,a4paper]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{trfrac}

\newenvironment{changemargin}[2]{%
\begin{list}{}{%
\setlength{\topsep}{0pt}%
\setlength{\leftmargin}{#1}% \setlength{\rightmargin}{#2}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{\parskip}%
}%
\item[]}{\end{list}}
  
\begin{document}
\title{Report for Lab Assignment 1, DD2457 Program Semantics and Analysis}
\author{Erik Helin}
\date{\today}
\maketitle
\newpage

\section*{New Rules}
The following new rules have been added to the various semantics:
\subsection*{Natural semantics}
\begingroup
\addtolength{\jot}{.5em}
\begin{align*}
[\text{try}_{ns}^1] \quad \quad &
<\texttt{try}\: S_1 \: \texttt{catch}\: S_2, \hat{s}> \rightarrow \hat{s} \\
[\text{try}_{ns}^2] \quad \quad &
\frac{<S_1,s> \rightarrow s^{'}}
     {<\texttt{try}\: S_1 \: \texttt{catch} \: S_2, s> \rightarrow s^{'}}  \\
[\text{try}_{ns}^3] \quad \quad &
\frac{<S_1,s> \rightarrow \hat{s}, \: <S_2, \hat{s}> \rightarrow s^{'}}
     {<\texttt{try}\: S_1 \: \texttt{catch} \: S_2, s> \rightarrow s^{'}} \\
[\text{ass}_{ns}^2] \quad \quad &
<x := a, \hat{s}> \rightarrow \hat{s} \\
[\text{ass}_{ns}^3] \quad \quad &
<x := a, s> \rightarrow \hat{s} \quad 
\text{if} \: \mathcal{A} \llbracket a \rrbracket s = \bot \\
[\text{skip}_{ns}^2] \quad \quad &
<\texttt{skip}, \hat{s}> \rightarrow \hat{s} \\
[\text{comp}_{ns}^2] \quad \quad &
<S_1;S_2, \hat{s}> \rightarrow \hat{s} \\
[\text{comp}_{ns}^3] \quad \quad &
\frac{<S_1, s> \rightarrow \hat{s}}{<S_1;S_2, s> \rightarrow \hat{s}} \\
[\text{comp}_{ns}^4] \quad \quad &
\frac{<S_1, s> \rightarrow s^{'}, <S_2, s^{'}> \rightarrow \hat{s}}
{<S_1;S_2, s> \rightarrow \hat{s}} \\
[\text{if}_{ns}^{\:3}] \quad \quad & <\texttt{if}\:b\: \texttt{then}\:  S_1 \: 
\texttt{else} \: S_2, \hat{s}> \rightarrow \hat{s} \\
[\text{if}_{ns}^{\:4}] \quad \quad & \frac{<S_1, s> \rightarrow \hat{s}}
{ <\texttt{if}\:b\: \texttt{then}\:  S_1 \: \texttt{else} \: S_2, s> 
\rightarrow \hat{s}} \quad \text{if} \: \mathcal{B} \llbracket b \rrbracket s
= \textbf{tt}\\
[\text{if}_{ns}^{\:5}] \quad \quad & \frac{<S_2, s> \rightarrow \hat{s}}
{ <\texttt{if}\:b\: \texttt{then}\:  S_1 \: \texttt{else} \: S_2, s> 
\rightarrow \hat{s}} \quad \text{if} \: \mathcal{B} \llbracket b \rrbracket s
= \textbf{ff}\\
[\text{if}_{ns}^{\:6}] \quad \quad & <\texttt{if}\:b\: \texttt{then}\:  S_1 \: 
\texttt{else} \: S_2, s> \rightarrow \hat{s} \quad 
\text{if} \: \mathcal{B} \llbracket b \rrbracket s
= \bot \\
[\text{while}_{ns}^3] \quad \quad & <\texttt{while}\: b \:\texttt{do}\: S, 
\hat{s}> \rightarrow \hat{s} \\
[\text{while}_{ns}^4] \quad \quad & 
<\texttt{while}\: b \:\texttt{do}\: S, s> \rightarrow \hat{s} 
\quad \text{if} \: \mathcal{B} \llbracket b \rrbracket s = \bot \\
[\text{while}_{ns}^5] \quad \quad & 
\frac{<S,s> \rightarrow s^{'}, <\texttt{while}\: b \: \texttt{do} \: S, s^{'}>
\rightarrow \hat{s}}
{<\texttt{while}\: b \: \texttt{do}\: S, s> \rightarrow \hat{s}} 
\quad \text{if} \: \mathcal{B} \llbracket b \rrbracket s = \textbf{tt} \\
\end{align*}
\endgroup

\subsection*{Arithmetic expressions}
\begin{align*}
\mathcal{A}\llbracket a_1 / a_2 \rrbracket(s) &= \mathcal{A}\llbracket a_1
\rrbracket(s) / \mathcal{A}\llbracket a_2 \rrbracket(s)\:& \text{if} \:
\mathcal{A}\llbracket a_2 \rrbracket(s) \neq 0 \\
\mathcal{A}\llbracket a_1 / a_2 \rrbracket(s) &= \bot\:& \text{if} \:
\mathcal{A}\llbracket a_2 \rrbracket(s) = 0 \\
\end{align*}

\subsection*{Boolean expressions}
\begin{align*} 
\mathcal{B}\llbracket a_1 = a_ 2 \rrbracket(s) &=
    \begin{cases}
        \textbf{tt} & \text{if } \mathcal{A}\llbracket a_1 \rrbracket(s) =
        \mathcal{A}\llbracket a_2 \rrbracket(s) \\
        \textbf{ff} & \text{if } \mathcal{A}\llbracket a_1 \rrbracket(s) \neq
        \mathcal{A}\llbracket a_2 \rrbracket(s)  \\
        \bot & \text{if } \mathcal{A}\llbracket a_1 \rrbracket(s) = \bot
                          \text{ or }
                          \mathcal{A} \llbracket a_2 \rrbracket (s) = \bot
    \end{cases} \\
\mathcal{B}\llbracket a_1 \leq a_2 \rrbracket(s) &= 
    \begin{cases}
        \textbf{tt} & \text{if } \mathcal{A}\llbracket a_1 \rrbracket(s) \leq
        \mathcal{A}\llbracket a_2 \rrbracket(s) \\
        \textbf{ff} & \text{if } \mathcal{A}\llbracket a_1 \rrbracket(s) >
        \mathcal{A}\llbracket a_2 \rrbracket(s)  \\
        \bot & \text{if } \mathcal{A}\llbracket a_1 \rrbracket(s) = \bot 
                          \text{ or }
                          \mathcal{A} \llbracket a_2 \rrbracket (s) = \bot
    \end{cases} \\
\mathcal{B}\llbracket \neg\, b \rrbracket(s) &= 
    \begin{cases}
        \textbf{tt} & \text{if } \mathcal{B}\llbracket b \rrbracket(s) =
        \textbf{ff} \\
        \textbf{ff} & \text{if } \mathcal{B}\llbracket b \rrbracket(s) =
        \textbf{tt} \\
        \bot & \text{if }\mathcal{B}\llbracket b \rrbracket(s) = \bot
    \end{cases} \\
\mathcal{B}\llbracket b_1 \land b_2 \rrbracket(s) &= 
    \begin{cases}
        \textbf{tt} & \text{if } \mathcal{B}\llbracket b_1 \rrbracket(s) =
        \textbf{tt} \text{ and } \mathcal{B}\llbracket b_2 \rrbracket(s) =
        \textbf{tt} \\
        \textbf{ff} & \text{if } \mathcal{B}\llbracket b_1 \rrbracket(s) =
        \textbf{ff} \text{ or } \mathcal{B}\llbracket b_2 \rrbracket(s) =
        \textbf{ff} \\
        \bot & \text{if }\mathcal{B}\llbracket b_1 \rrbracket(s) = \bot
                         \text{ or }
                         \mathcal{B}\llbracket b_2 \rrbracket(s) = \bot
    \end{cases}
\end{align*}

\subsection*{AM instructions}
\begin{align*}
\text{DIV}\: |\: \text{TRY}\:(c_1,c_2)\: |\: \text{CATCH}\:(c)
\end{align*}

\subsection*{AM translations}
\begin{align*}
\mathcal{CA}\llbracket a_1 / a_2 \rrbracket = 
    \mathcal{CA}\llbracket a_2 \rrbracket:
    \mathcal{CA}\llbracket a_1 \rrbracket:\textsc{DIV}
\end{align*}

\subsection*{AM Structural Operational Rules}
\begingroup
\addtolength{\jot}{.5em}
\begin{align*}
<\text{DIV}:c, n_1:n_2:e, s> \: &\triangleright <c, (n_1 / n_2):e, s>& \quad 
\text{if} \; n_1, n_2 \in \mathbb{Z}, n_2 \neq 0 \\
<\text{DIV}:c, n_1:n_2:e, s> \: &\triangleright <c, e, \hat{s}>& \quad
\text{if} \; n_1, n_2 \in \mathbb{Z}, n_2 = 0 \\
<\text{TRY}\:(c_1, c_2):c, e, s> \: &\triangleright 
<c_1:\text{CATCH}\:(c_2):c, e, s>& \\
<\text{CATCH}\:(c_1):c, e, s>\: &\triangleright <c, e, s>& \\
<\text{CATCH}\:(c_1):c, e, \hat{s}>\: &\triangleright <c_1:c, e, s>& \\
<c_1:c, e, \hat{s}>\: &\triangleright <c, e, \hat{s}>&
\end{align*}
\endgroup

\subsection*{Derivation tree}
Here follows the derivation tree of the program
\begin{verbatim}
x := 7; try x := x - 7; x := 7 / x; x := x + 7 catch x := x - 7
\end{verbatim}
\begin{changemargin}{-2.5cm}{\rightmargin}
\[
\trfrac[\(\text{comp}_{ns}\)]{
\trfrac[\(\text{ass}_{ns}\)]{s_0[x \mapsto 7]}{<x := 7, s_0> \rightarrow s_2}
\trfrac[\(\text{try}^3_{ns}\)]{
\trfrac[\(\text{comp}_{ns}\)]{T_1}
{<x := x - 7; x := 7 / x; x := x + 7, s_2> \rightarrow \hat{s}_3} 
\trfrac[\(\text{ass}_{ns}\)]{s_3[x \mapsto s_3(x) - 7\:]}
{<x := x - 7, \hat{s}_3> \rightarrow s_1}}
{<\textbf{try}\: x := x - 7; x := 7 / x; x := x + 7 \: \textbf{catch}\:
x := x - 7, s_2> \rightarrow s_1}}
{<x := 7; \textbf{try}\: x := x - 7; x := 7 / x; x := x + 7 \: \textbf{catch}\:
x := x - 7, s_0> \rightarrow s_1}
\]
\end{changemargin}
\[
\trfrac[]{
\trfrac[\(\text{ass}_{ns}\)]{s_2[x \mapsto s_2(x) - 7]}
{<x := x - 7, s_2> \rightarrow s_3}
\trfrac[\(\text{comp}_{ns}\)]{
\trfrac[\(\text{ass}^3_{ns}\)]{\hat{s}_3 = (s_3, \bot)}
{<x := 7/x, s_3> \rightarrow \hat{s}_3}
<x := x + 7, \hat{s_3}> \rightarrow \hat{s}_3}
{<x := 7 / x; x := x + 7, s_3> \rightarrow \hat{s}_3}
}{T_1}
\]

where
\begin{align*}
s_2 &= (s_0[x \mapsto 7], \top) \\
s_3 &= (s_2[x \mapsto s_2(x) - 7], \top) = (s_0[x \mapsto 0], \top) \\
\hat{s}_3 &= (s_3, \bot) = (s_0[x \mapsto 0], \bot) \\
s_1 &= (s_3[x \mapsto s_3(x) - 7], \top) = (s_0[x \mapsto s_0(x) - 7], \top) =
(s_0[x \mapsto -7], \top)
\end{align*}

\subsection*{Execution of sample}
Here follows the execution of the program from an arbitrary 
state \(s\).
\begin{verbatim}
x := 7; try x := x - 7; x := 7 / x; x := x + 7 catch x := x - 7
\end{verbatim}
\begin{changemargin}{-3.4cm}{\rightmargin}
\noindent
\tiny
\input{trycatch.output}
\normalsize
\end{changemargin}

\subsection*{Argument of correctness}
The modified version of lemma 4.18 used in class still holds, 
but the lemma have to be adjusted a little bit to take the 
extended states into account:

{\bf Lemma 4.18*} 
\begin{align*}
\forall a \in \text{AExp}.\forall c \in \text{Code}.\forall e \in \text{Stack}.
\forall s \in \text{EState}. \\
\langle\mathcal{CA}\llbracket a \rrbracket:c, e, s \rangle \triangleright^+ 
\langle c, \mathcal{A}\llbracket a \rrbracket:e, s \rangle
\end{align*}

{\bf Proof}
The proof is the same as before (the one we did in class), 
but a new case is added for division
\begin{align*}
[a \equiv a_1 / a_2]&\:\:\:\:\:\: \langle \mathcal{CA}\llbracket a_1 / a_2 
\rrbracket:c,
e, s \rangle \\
&= \langle \mathcal{CA}\llbracket a_2 \rrbracket:\mathcal{CA} \llbracket a_1
\rrbracket:\textsc{DIV}:c, e, s\rangle & \{\text{def}\:\mathcal{CA}\} \\
&\triangleright^+ \langle \mathcal{CA} \llbracket a_1 \rrbracket:\textsc{DIV}:c,
\mathcal{A}\llbracket a_2 \rrbracket(s):e, s \rangle & \{\text{ind. hyp.}\} \\
&\triangleright^+ \langle \textsc{DIV}:c,
\mathcal{A}\llbracket a_1 \rrbracket(s):\mathcal{A}\llbracket a_2 
\rrbracket(s):e, 
s \rangle & \{\text{ind. hyp.}\} \\
&\triangleright \langle c, (\mathcal{A}\llbracket a_1 \rrbracket(s) /
\mathcal{A}\llbracket a_2 \rrbracket(s)):e, s \rangle & \{\text{def}\: 
\triangleright\} \\
\end{align*}

Since lemma 4.18* holds, lemma 4.19 holds since \(\mathcal{CB}\) in unchanged  
and since both 
\(\mathcal{S}_{ns}\) and \(\mathcal{S}_{am}\) now has type \(\textbf{Stm } 
\rightarrow (\textbf{ EState }
\hookrightarrow \textbf{ EState})\), 
theorem 4.20 still holds for the original semantic of \textbf{While}. In order
for the proof to hold for the extended version \textbf{While} with the {\bf
try} \(S_1\) {\bf catch} \(S_2\) statement added, 
a proof for that rule has to be added to the proof of theorem 4.20.

\subsection*{Examples}
The implementation was tested with all the examples in the folder 
\texttt{/info/semant11/lab1/samples} all well as the following examples.
\subsubsection*{Example 1}
\begin{description}
\item[Description] Exception in the boolean condition of an if statement 
\item[Result] \((s[x \mapsto 0], \bot)\) for all initial states \(s\)
\item[Code]
\begin{verbatim}
x := 0; if 7 / 0 <= 7 then x := 1 else x := 2; x := x - 2 
\end{verbatim}
\end{description}

\subsubsection*{Example 2}
\begin{description}
\item[Description] Exception in the boolean condition of a while loop
\item[Result] \((s[x \mapsto 1], \bot)\) for all initial states \(s\)
\item[Code]
\begin{verbatim}
x := 1; while x <= x / 0 do x := x + 1; x := x - 1
\end{verbatim}
\end{description}

\subsubsection*{Example 3}
\begin{description}
\item[Description] An exception before a try/catch statement
\item[Result] \((s, \bot)\) for all initial states \(s\)
\item[Code]
\begin{verbatim}
x := 7 / 0; try x := 1 catch x := 2; x := 3
\end{verbatim}
\end{description}

\subsubsection*{Example 4}
\begin{description}
\item[Description] An exception in a catch statement of a nested try/catch
statement
\item[Result] \((s[x \mapsto 5][y \mapsto 10], \top)\) for all initial states
\(s\)
\item[Code] \hfill
\begin{verbatim}
x := 0;
y := 0;
try
    try
        x := 0;
        y := 5 / x
    catch
        x := 5;
        y := 0;
        x := 5 / y
catch
    y := x + x
\end{verbatim}
\end{description}
\end{document}
